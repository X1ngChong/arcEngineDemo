package com.demo.before;import com.Bean.Point;import com.Common.InfoCommon;import com.Util.Neo4jCalculatePointUtil;import com.Util.RoadUtils;import org.neo4j.driver.*;import java.awt.geom.Line2D;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 分批次执行neo4j数据的写入 */public class Test4 {    private static int count = 0;    public static void main(String[] args) {        final int batchSize = 50;        int startNumber = 0;        int endNumber = 40000;        Driver driver = GraphDatabase.driver(InfoCommon.url, AuthTokens.basic(InfoCommon.username, InfoCommon.password));             Session session = driver.session();        List<Line2D.Double[]> roadSegmentsList = new ArrayList<>();        List<String> roadOsmList = new ArrayList<>();        //先加载所有的道路        try (Transaction tx = session.beginTransaction()) {            String cypherQuery = "MATCH (n:xianlinRoads) where n.osm_id <> 'null' RETURN n.geometry as linePoint , n.osm_id as roadOsm ";            Result result = tx.run(cypherQuery);            if (!result.hasNext()){                System.out.println("导入结束");            }            while (result.hasNext()) {                Record record2 = result.next();                String roadOsm = record2.get("roadOsm").asString();//获取osm_id                String linePoint = record2.get("linePoint").asString();                List<Double> coordinates = RoadUtils.extractNumbers(linePoint);                Line2D.Double[] roadSegments = RoadUtils.convertToLineSegments(coordinates);                roadSegmentsList.add(roadSegments);//构建所有道路折点                roadOsmList.add(roadOsm);            }        }        while (startNumber < endNumber) {            int currentEnd = Math.min(startNumber + batchSize, endNumber);            System.out.println("第" + (startNumber / batchSize) + "次分批导入");            insert(startNumber, currentEnd,session,roadSegmentsList,roadOsmList);            startNumber += batchSize;        }        session.close();        driver.close();    }    public static void insert(Integer beginNumber,Integer endNumber, Session session, List<Line2D.Double[]> roadSegmentsList,  List<String> roadOsmList) {            try (Transaction tx = session.beginTransaction()) {                // 执行 Cypher 查询    分批次执行                String cypherQuery = "MATCH p=()-[r:NEAR]->() RETURN p, id(r) as id skip "+beginNumber+" limit "+ endNumber;//查询所有关系节点                Result result = tx.run(cypherQuery);                // 处理查询结果                while (result.hasNext()) {                    Record record = result.next();                    // 获取节点数据                    List start = record.get("p").asPath().start().get("bbox").asList();                    List end = record.get("p").asPath().end().get("bbox").asList();                    int relationshipId = record.get("id").asInt();                    Point sPpint = Neo4jCalculatePointUtil.calculateCenterAsPoint(start);                    Point ePpint = Neo4jCalculatePointUtil.calculateCenterAsPoint(end);                    // 俩个道路之间的线段                    Line2D.Double line1 = new Line2D.Double(sPpint.getX(), sPpint.getY(), ePpint.getX(), ePpint.getY());                        // 获取节点数据osm的id                        String aosmId = record.get("p").asPath().start().get("osm_id").asString();                        String bosmId = record.get("p").asPath().end().get("osm_id").asString();                        // 在主逻辑中调用封装的方法                    checkAndUpdateIntersection(tx, line1,aosmId, bosmId, relationshipId, roadOsmList,roadSegmentsList);                }                // 提交事务                System.out.println("正在提交事务");                tx.commit();            }    }    private static boolean checkAndUpdateIntersection(Transaction tx, Line2D.Double line1,  String aosmId, String bosmId, int relationshipId,  List<String> roadOsmList, List<Line2D.Double[]> roadSegmentsList) {        // 在主逻辑中调用封装的方法            for(int i = 0 ;i<roadSegmentsList.size();i++){                Line2D.Double[] roadSegments = roadSegmentsList.get(i);                for (Line2D.Double roadSegment : roadSegments) {            if (RoadUtils.checkIntersection(roadSegment, line1)) {                // 创建一个新的关系                String cypherQuery3 = "MATCH (a {osm_id: $ad})-[r:NEAR]->(b {osm_id: $bd}) WHERE id(r) = $relationshipId and r.line is null SET r.line = $line return r ";                Map<String, Object> parameters = new HashMap<>();                parameters.put("ad", aosmId);                parameters.put("bd", bosmId);                parameters.put("relationshipId", relationshipId);                parameters.put("line", roadOsmList.get(i));                Result result3 = tx.run(cypherQuery3, parameters);                if (result3.hasNext()) {                    Record record3 = result3.next();                    System.out.println("添加成功"+ count++ );                    // 直接返回true表示找到并处理了相交线段                    return true;                }            }        }        }        // 如果没有找到相交的线段，返回false        return false;    }}